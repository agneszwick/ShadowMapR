#' Calculate Solar Position for a Full Day
#'
#' This function calculates the solar position for each hour of the specified day.
#' For each hour, the solar position is computed for the provided building geometries,
#' and only positions with a positive solar elevation are returned.
#'
#' @param building_sf sf object containing building geometries. Each geometry should represent
#'        a building or structure for which solar position will be calculated.
#' @param date Date object (class `Date`) specifying the day for the calculations.
#'        The time zone will be set to UTC.
#'
#' @return A list of sf objects. Each element in the list corresponds to a specific hour of the day
#'         (e.g., "2025-02-24 - 12:00") and contains the solar positions for the buildings at that hour.
#'         Only solar positions with a positive solar elevation are included.
#'
#' @export
calculate_solar_day <- function(building_sf, date) {
  results <- list()
  for (hour in 0:23) {
    time <- as.POSIXct(paste(date, sprintf("%02d:00:00", hour)), tz = "UTC")
    solar_data <- sun_position(building_sf, time)
    if (any(solar_data$sol_elevation > 0)) {
      label <- sprintf("%s - %02d:00", date, hour)
      results[[label]] <- solar_data[solar_data$sol_elevation > 0, ]
    }
  }
  return(results)
}


#' Calculate Hourly Shadows
#'
#' This function calculates the shadows for each hour based on the provided solar results.
#' It applies the `building_offset` function to each hourly solar data in the input list.
#'
#' @param solar_results A list containing hourly solar data, where each element represents
#'        solar data for a specific hour (e.g., solar elevation, azimuth, etc.).
#'        This data should have been generated by a previous solar position calculation.
#'
#' @return A list of calculated shadows for each hour. Each element in the list corresponds
#'         to an hour from the input `solar_results` and contains the resulting shadow information
#'         calculated based on the solar data.
#'
#' @export
calculate_hourly_shadow_offset <- function(solar_results) {
  # Apply the building_offset function to each hourly solar data
  lapply(solar_results, function(hourly_data) {
    # Ensure that building_offset is defined and works on the given data
    building_offset(hourly_data)
  })
}


#' Create Hourly Shadow Polygons
#'
#' This function creates shadow polygons for each hour based on the provided shadow data.
#' It processes the shadows in batches, and for each batch, it calculates the corresponding
#' shadow polygons using the `shadow_polygons` function.
#'
#' @param shadows A list of shadows for each hour, where each element corresponds to shadow
#'        data for a specific hour. The shadows should have been calculated previously.
#' @param batch_size An integer specifying the number of buildings to process in each batch.
#'        The default value is 50. Adjusting this value may improve performance depending
#'        on the size of the dataset.
#'
#' @import sf
#'
#' @return A named list of shadow polygons for each hour. Each element in the list corresponds
#'         to an hour and contains the resulting shadow polygons calculated from the shadow data.
#'
#' @export
create_hourly_shadow_polygons <- function(shadows, batch_size = 50) {
  setNames(
    lapply(names(shadows), function(hour) {
      shadow_polygons(shadows[[hour]], batch_size)
    }),
    names(shadows)
  )
}

#' Create hourly sunlight areas
#' @param shadow_polygons A named list of shadow polygons for each hour.
#' @param building_sf An sf object containing building geometries.
#' @return A named list of sunlight areas for each hour.
#' @export
create_hourly_sunlight_areas <- function(shadow_polygons, building_sf) {
  setNames(
    lapply(names(shadow_polygons), function(hour) {
      create_sunlight_areas(building_sf, shadow_polygons[[hour]])
    }),
    names(shadow_polygons)
  )
}

#' Precompute Map Layers for Each Hour
#'
#' This function precomputes the map layers for each hour, including building geometries,
#' shadow polygons, and sunlight areas. For each hour, it returns the corresponding
#' geometries and calculates the necessary map layers by merging the building geometries
#' with the shadows and sunlight areas.
#'
#' @param building_sf An sf object containing building geometries. Each geometry should
#'        represent a building or structure for which the map layers will be created.
#' @param shadow_polygons A named list of shadow polygons for each hour. Each element in
#'        the list corresponds to shadow polygons for a specific hour.
#' @param sunlight_area A named list of sunlight areas for each hour. Each element in the
#'        list corresponds to sunlight areas for a specific hour.
#'
#' @import sf
#'
#' @return A named list of lists. Each inner list contains three sf objects:
#'   \itemize{
#'     \item{buildings}{The union of all building geometries.}
#'     \item{shadows}{The shadow polygons for the specific hour.}
#'     \item{sunlight}{The sunlight areas for the specific hour.}
#'   }
#'   The outer list is named by the hour, corresponding to the input shadow polygons and sunlight areas.
#'
#' @export
precompute_map_layers <- function(building_sf, shadow_polygons, sunlight_areas) {
  # Union all building geometries
  building_union <- st_union(building_sf)

  # Initialize the final map layers
  final_map_layers <- list()

  # Iterate over each hour and prepare the layers for that hour
  for (hour in names(shadow_polygons)) {
    # Get the corresponding polygons for this hour
    shadow_data <- shadow_polygons[[hour]]
    sunlight_data <- sunlight_areas[[hour]]
    building_data <- building_union  # The buildings are the same for all hours, use transformed building data

    # Create the map layer for the current hour
    final_map_layers[[hour]] <- list(
      buildings = building_data,
      shadows = shadow_data,
      sunlight = sunlight_data
    )
  }

  # Return the final map layers
  return(final_map_layers)
}
